import {
  Provider,
  atom,
  createStore,
  useAtom,
  useAtomValue,
  useSetAtom,
  useStore
} from "./chunk-FLLWPT42.js";
import {
  require_jsx_runtime
} from "./chunk-LYCPHDFZ.js";
import {
  require_react
} from "./chunk-TGGRJORP.js";
import {
  __toESM
} from "./chunk-3EJPJMEH.js";

// ../node_modules/jotai-scope/dist/index.modern.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react3 = __toESM(require_react());

// ../node_modules/jotai/esm/react/utils.mjs
var import_react = __toESM(require_react(), 1);

// ../node_modules/jotai/esm/vanilla/utils.mjs
var RESET = Symbol(
  (import.meta.env ? import.meta.env.MODE : void 0) !== "production" ? "RESET" : ""
);
var isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === "function";
function createJSONStorage(getStringStorage = () => {
  try {
    return window.localStorage;
  } catch (e) {
    if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
      if (typeof window !== "undefined") {
        console.warn(e);
      }
    }
    return void 0;
  }
}, options) {
  var _a;
  let lastStr;
  let lastValue;
  const storage = {
    getItem: (key, initialValue) => {
      var _a2, _b;
      const parse = (str2) => {
        str2 = str2 || "";
        if (lastStr !== str2) {
          try {
            lastValue = JSON.parse(str2, options == null ? void 0 : options.reviver);
          } catch (e) {
            return initialValue;
          }
          lastStr = str2;
        }
        return lastValue;
      };
      const str = (_b = (_a2 = getStringStorage()) == null ? void 0 : _a2.getItem(key)) != null ? _b : null;
      if (isPromiseLike(str)) {
        return str.then(parse);
      }
      return parse(str);
    },
    setItem: (key, newValue) => {
      var _a2;
      return (_a2 = getStringStorage()) == null ? void 0 : _a2.setItem(
        key,
        JSON.stringify(newValue, options == null ? void 0 : options.replacer)
      );
    },
    removeItem: (key) => {
      var _a2;
      return (_a2 = getStringStorage()) == null ? void 0 : _a2.removeItem(key);
    }
  };
  const createHandleSubscribe = (subscriber2) => (key, callback, initialValue) => subscriber2(key, (v) => {
    let newValue;
    try {
      newValue = JSON.parse(v || "");
    } catch (e) {
      newValue = initialValue;
    }
    callback(newValue);
  });
  let subscriber;
  try {
    subscriber = (_a = getStringStorage()) == null ? void 0 : _a.subscribe;
  } catch (e) {
  }
  if (!subscriber && typeof window !== "undefined" && typeof window.addEventListener === "function" && window.Storage) {
    subscriber = (key, callback) => {
      if (!(getStringStorage() instanceof window.Storage)) {
        return () => {
        };
      }
      const storageEventCallback = (e) => {
        if (e.storageArea === getStringStorage() && e.key === key) {
          callback(e.newValue);
        }
      };
      window.addEventListener("storage", storageEventCallback);
      return () => {
        window.removeEventListener("storage", storageEventCallback);
      };
    };
  }
  if (subscriber) {
    storage.subscribe = createHandleSubscribe(subscriber);
  }
  return storage;
}
var defaultStorage = createJSONStorage();

// ../node_modules/jotai/esm/react/utils.mjs
var hydratedMap = /* @__PURE__ */ new WeakMap();
function useHydrateAtoms(values, options) {
  const store = useStore(options);
  const hydratedSet = getHydratedSet(store);
  for (const [atom2, value] of values) {
    if (!hydratedSet.has(atom2) || (options == null ? void 0 : options.dangerouslyForceHydrate)) {
      hydratedSet.add(atom2);
      store.set(atom2, value);
    }
  }
}
var getHydratedSet = (store) => {
  let hydratedSet = hydratedMap.get(store);
  if (!hydratedSet) {
    hydratedSet = /* @__PURE__ */ new WeakSet();
    hydratedMap.set(store, hydratedSet);
  }
  return hydratedSet;
};

// ../node_modules/jotai-scope/dist/index.modern.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function createIsolation() {
  const StoreContext = (0, import_react3.createContext)(null);
  function Provider2({
    store,
    initialValues = [],
    children
  }) {
    const storeRef = (0, import_react3.useRef)(store);
    if (!storeRef.current) {
      storeRef.current = createStore();
    }
    useHydrateAtoms(initialValues, {
      store: storeRef.current
    });
    return (0, import_jsx_runtime.jsx)(StoreContext.Provider, {
      value: storeRef.current,
      children
    });
  }
  const useStore$1 = (options) => {
    const store = (0, import_react3.useContext)(StoreContext);
    if (!store)
      throw new Error("Missing Provider from createIsolation");
    return useStore(_extends({
      store
    }, options));
  };
  const useAtom$1 = (anAtom, options) => {
    const store = useStore$1();
    return useAtom(anAtom, _extends({
      store
    }, options));
  };
  const useAtomValue$1 = (anAtom, options) => {
    const store = useStore$1();
    return useAtomValue(anAtom, _extends({
      store
    }, options));
  };
  const useSetAtom$1 = (anAtom, options) => {
    const store = useStore$1();
    return useSetAtom(anAtom, _extends({
      store
    }, options));
  };
  return {
    Provider: Provider2,
    useStore: useStore$1,
    useAtom: useAtom$1,
    useAtomValue: useAtomValue$1,
    useSetAtom: useSetAtom$1
  };
}
var globalScopeKey = {};
if (true) {
  globalScopeKey.name = "unscoped";
  globalScopeKey.toString = toString;
}
function createScope(atoms, atomFamilies, parentScope, scopeName) {
  const explicit = /* @__PURE__ */ new WeakMap();
  const implicit = /* @__PURE__ */ new WeakMap();
  const inherited = /* @__PURE__ */ new WeakMap();
  const currentScope = {
    getAtom,
    cleanup() {
    },
    prepareWriteAtom(anAtom, originalAtom, implicitScope) {
      if (originalAtom.read === defaultRead && isWritableAtom(originalAtom) && isWritableAtom(anAtom) && originalAtom.write !== defaultWrite && currentScope !== implicitScope) {
        const {
          write
        } = originalAtom;
        anAtom.write = createScopedWrite(originalAtom.write.bind(originalAtom), implicitScope);
        return () => {
          anAtom.write = write;
        };
      }
      return void 0;
    }
  };
  if (scopeName && true) {
    currentScope.name = scopeName;
    currentScope.toString = toString;
  }
  for (const anAtom of atoms) {
    explicit.set(anAtom, [cloneAtom(anAtom, currentScope), currentScope]);
  }
  const cleanupFamiliesSet = /* @__PURE__ */ new Set();
  for (const atomFamily of atomFamilies) {
    for (const param of atomFamily.getParams()) {
      const anAtom = atomFamily(param);
      if (!explicit.has(anAtom)) {
        explicit.set(anAtom, [cloneAtom(anAtom, currentScope), currentScope]);
      }
    }
    const cleanupFamily = atomFamily.unstable_listen((e) => {
      if (e.type === "CREATE" && !explicit.has(e.atom)) {
        explicit.set(e.atom, [cloneAtom(e.atom, currentScope), currentScope]);
      } else if (!atoms.has(e.atom)) {
        explicit.delete(e.atom);
      }
    });
    cleanupFamiliesSet.add(cleanupFamily);
  }
  currentScope.cleanup = combineVoidFunctions(currentScope.cleanup, ...Array.from(cleanupFamiliesSet));
  function getAtom(anAtom, implicitScope) {
    var _inherited$get2;
    if (explicit.has(anAtom)) {
      return explicit.get(anAtom);
    }
    if (implicitScope === currentScope) {
      if (!implicit.has(anAtom)) {
        implicit.set(anAtom, [cloneAtom(anAtom, implicitScope), implicitScope]);
      }
      return implicit.get(anAtom);
    }
    const scopeKey = implicitScope != null ? implicitScope : globalScopeKey;
    if (parentScope) {
      var _inherited$get;
      if (!((_inherited$get = inherited.get(scopeKey)) != null && _inherited$get.has(anAtom))) {
        const [ancestorAtom, explicitScope] = parentScope.getAtom(anAtom, implicitScope);
        setInheritedAtom(inheritAtom(ancestorAtom, anAtom, explicitScope), anAtom, implicitScope, explicitScope);
      }
      return inherited.get(scopeKey).get(anAtom);
    }
    if (!((_inherited$get2 = inherited.get(scopeKey)) != null && _inherited$get2.has(anAtom))) {
      setInheritedAtom(inheritAtom(anAtom, anAtom), anAtom);
    }
    return inherited.get(scopeKey).get(anAtom);
  }
  function setInheritedAtom(scopedAtom, originalAtom, implicitScope, explicitScope) {
    const scopeKey = implicitScope != null ? implicitScope : globalScopeKey;
    if (!inherited.has(scopeKey)) {
      inherited.set(scopeKey, /* @__PURE__ */ new WeakMap());
    }
    inherited.get(scopeKey).set(originalAtom, [scopedAtom, explicitScope].filter(Boolean));
  }
  function inheritAtom(anAtom, originalAtom, implicitScope) {
    if (originalAtom.read !== defaultRead) {
      return cloneAtom(originalAtom, implicitScope);
    }
    return anAtom;
  }
  function cloneAtom(originalAtom, implicitScope) {
    const scopedAtom = Object.create(Object.getPrototypeOf(originalAtom), Object.getOwnPropertyDescriptors(originalAtom));
    if (scopedAtom.read !== defaultRead) {
      scopedAtom.read = createScopedRead(originalAtom.read.bind(originalAtom), implicitScope);
    }
    if (isWritableAtom(scopedAtom) && isWritableAtom(originalAtom) && scopedAtom.write !== defaultWrite) {
      scopedAtom.write = createScopedWrite(originalAtom.write.bind(originalAtom), implicitScope);
    }
    return scopedAtom;
  }
  function createScopedRead(read, implicitScope) {
    return function scopedRead(get, opts) {
      return read(
        function scopedGet(a) {
          const [scopedAtom] = getAtom(a, implicitScope);
          return get(scopedAtom);
        },
        //
        opts
      );
    };
  }
  function createScopedWrite(write, implicitScope) {
    return function scopedWrite(get, set, ...args) {
      return write(function scopedGet(a) {
        const [scopedAtom] = getAtom(a, implicitScope);
        return get(scopedAtom);
      }, function scopedSet(a, ...v) {
        const [scopedAtom] = getAtom(a, implicitScope);
        return set(scopedAtom, ...v);
      }, ...args);
    };
  }
  return currentScope;
}
function isWritableAtom(anAtom) {
  return "write" in anAtom;
}
var {
  read: defaultRead,
  write: defaultWrite
} = atom(null);
function toString() {
  return this.name;
}
function combineVoidFunctions(...fns) {
  return function combinedFunctions() {
    for (const fn of fns) {
      fn();
    }
  };
}
function PatchedStore() {
}
function createPatchedStore(baseStore, scope) {
  const store = _extends({}, baseStore, {
    get(anAtom, ...args) {
      const [scopedAtom] = scope.getAtom(anAtom);
      return baseStore.get(scopedAtom, ...args);
    },
    set(anAtom, ...args) {
      const [scopedAtom, implicitScope] = scope.getAtom(anAtom);
      const restore = scope.prepareWriteAtom(scopedAtom, anAtom, implicitScope);
      try {
        return baseStore.set(scopedAtom, ...args);
      } finally {
        restore == null || restore();
      }
    },
    sub(anAtom, ...args) {
      const [scopedAtom] = scope.getAtom(anAtom);
      return baseStore.sub(scopedAtom, ...args);
    }
    // TODO: update this patch to support devtools
  });
  return Object.assign(Object.create(PatchedStore.prototype), store);
}
function isTopLevelScope(parentStore) {
  return !(parentStore instanceof PatchedStore);
}
var ScopeContext = (0, import_react3.createContext)({
  scope: void 0,
  baseStore: void 0
});
function ScopeProvider({
  atoms,
  atomFamilies,
  children,
  debugName
}) {
  const parentStore = useStore();
  let {
    scope: parentScope,
    baseStore = parentStore
  } = (0, import_react3.useContext)(ScopeContext);
  if (isTopLevelScope(parentStore)) {
    parentScope = void 0;
    baseStore = parentStore;
  }
  const atomSet = new Set(atoms);
  const atomFamilySet = new Set(atomFamilies);
  function initialize() {
    const scope = createScope(atomSet, atomFamilySet, parentScope, debugName);
    return {
      patchedStore: createPatchedStore(baseStore, scope),
      scopeContext: {
        scope,
        baseStore
      },
      hasChanged(current) {
        return parentScope !== current.parentScope || baseStore !== current.baseStore || !isEqualSet(atomSet, current.atomSet) || !isEqualSet(atomFamilySet, current.atomFamilySet);
      }
    };
  }
  const [state, setState] = (0, import_react3.useState)(initialize);
  const {
    hasChanged,
    scopeContext,
    patchedStore
  } = state;
  if (hasChanged({
    parentScope,
    atomSet,
    atomFamilySet,
    baseStore
  })) {
    var _scopeContext$scope;
    (_scopeContext$scope = scopeContext.scope) == null || _scopeContext$scope.cleanup();
    setState(initialize);
  }
  const {
    cleanup
  } = scopeContext.scope;
  useEvent(() => cleanup, []);
  return (0, import_jsx_runtime.jsx)(ScopeContext.Provider, {
    value: scopeContext,
    children: (0, import_jsx_runtime.jsx)(Provider, {
      store: patchedStore,
      children
    })
  });
}
function isEqualSet(a, b) {
  return a === b || a.size === b.size && Array.from(a).every((v) => b.has(v));
}
function useEvent(fn, deps) {
  const ref = (0, import_react3.useRef)(fn);
  ref.current = fn;
  (0, import_react3.useEffect)(() => ref.current(), deps);
}
export {
  ScopeProvider,
  createIsolation
};
//# sourceMappingURL=jotai-scope.js.map
