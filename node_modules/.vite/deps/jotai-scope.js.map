{
  "version": 3,
  "sources": ["../../../../node_modules/jotai/esm/react/utils.mjs", "../../../../node_modules/jotai/esm/vanilla/utils.mjs", "../../../../node_modules/jotai-scope/src/createIsolation.tsx", "../../../../node_modules/jotai-scope/src/ScopeProvider/scope.ts", "../../../../node_modules/jotai-scope/src/ScopeProvider/patchedStore.ts", "../../../../node_modules/jotai-scope/src/ScopeProvider/ScopeProvider.tsx"],
  "sourcesContent": ["'use client';\nimport { useCallback, useMemo } from 'react';\nimport { useSetAtom, useAtom, useStore } from 'jotai/react';\nimport { RESET } from 'jotai/vanilla/utils';\nimport { atom } from 'jotai/vanilla';\n\nfunction useResetAtom(anAtom, options) {\n  const setAtom = useSetAtom(anAtom, options);\n  const resetAtom = useCallback(() => setAtom(RESET), [setAtom]);\n  return resetAtom;\n}\n\nfunction useReducerAtom(anAtom, reducer, options) {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] useReducerAtom is deprecated and will be removed in the future. Please create your own version using the recipe. https://github.com/pmndrs/jotai/pull/2467\"\n    );\n  }\n  const [state, setState] = useAtom(anAtom, options);\n  const dispatch = useCallback(\n    (action) => {\n      setState((prev) => reducer(prev, action));\n    },\n    [setState, reducer]\n  );\n  return [state, dispatch];\n}\n\nfunction useAtomCallback(callback, options) {\n  const anAtom = useMemo(\n    () => atom(null, (get, set, ...args) => callback(get, set, ...args)),\n    [callback]\n  );\n  return useSetAtom(anAtom, options);\n}\n\nconst hydratedMap = /* @__PURE__ */ new WeakMap();\nfunction useHydrateAtoms(values, options) {\n  const store = useStore(options);\n  const hydratedSet = getHydratedSet(store);\n  for (const [atom, value] of values) {\n    if (!hydratedSet.has(atom) || (options == null ? void 0 : options.dangerouslyForceHydrate)) {\n      hydratedSet.add(atom);\n      store.set(atom, value);\n    }\n  }\n}\nconst getHydratedSet = (store) => {\n  let hydratedSet = hydratedMap.get(store);\n  if (!hydratedSet) {\n    hydratedSet = /* @__PURE__ */ new WeakSet();\n    hydratedMap.set(store, hydratedSet);\n  }\n  return hydratedSet;\n};\n\nexport { useAtomCallback, useHydrateAtoms, useReducerAtom, useResetAtom };\n", "import { atom } from 'jotai/vanilla';\n\nconst RESET = Symbol(\n  (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" ? \"RESET\" : \"\"\n);\n\nfunction atomWithReset(initialValue) {\n  const anAtom = atom(\n    initialValue,\n    (get, set, update) => {\n      const nextValue = typeof update === \"function\" ? update(get(anAtom)) : update;\n      set(anAtom, nextValue === RESET ? initialValue : nextValue);\n    }\n  );\n  return anAtom;\n}\n\nfunction atomWithReducer(initialValue, reducer) {\n  return atom(initialValue, function(get, set, action) {\n    set(this, reducer(get(this), action));\n  });\n}\n\nfunction atomFamily(initializeAtom, areEqual) {\n  let shouldRemove = null;\n  const atoms = /* @__PURE__ */ new Map();\n  const listeners = /* @__PURE__ */ new Set();\n  const createAtom = (param) => {\n    let item;\n    if (areEqual === void 0) {\n      item = atoms.get(param);\n    } else {\n      for (const [key, value] of atoms) {\n        if (areEqual(key, param)) {\n          item = value;\n          break;\n        }\n      }\n    }\n    if (item !== void 0) {\n      if (shouldRemove == null ? void 0 : shouldRemove(item[1], param)) {\n        createAtom.remove(param);\n      } else {\n        return item[0];\n      }\n    }\n    const newAtom = initializeAtom(param);\n    atoms.set(param, [newAtom, Date.now()]);\n    notifyListeners(\"CREATE\", param, newAtom);\n    return newAtom;\n  };\n  function notifyListeners(type, param, atom) {\n    for (const listener of listeners) {\n      listener({ type, param, atom });\n    }\n  }\n  createAtom.unstable_listen = (callback) => {\n    listeners.add(callback);\n    return () => {\n      listeners.delete(callback);\n    };\n  };\n  createAtom.getParams = () => atoms.keys();\n  createAtom.remove = (param) => {\n    if (areEqual === void 0) {\n      if (!atoms.has(param)) return;\n      const [atom] = atoms.get(param);\n      atoms.delete(param);\n      notifyListeners(\"REMOVE\", param, atom);\n    } else {\n      for (const [key, [atom]] of atoms) {\n        if (areEqual(key, param)) {\n          atoms.delete(key);\n          notifyListeners(\"REMOVE\", key, atom);\n          break;\n        }\n      }\n    }\n  };\n  createAtom.setShouldRemove = (fn) => {\n    shouldRemove = fn;\n    if (!shouldRemove) return;\n    for (const [key, [atom, createdAt]] of atoms) {\n      if (shouldRemove(createdAt, key)) {\n        atoms.delete(key);\n        notifyListeners(\"REMOVE\", key, atom);\n      }\n    }\n  };\n  return createAtom;\n}\n\nconst getCached$2 = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1$3 = /* @__PURE__ */ new WeakMap();\nconst memo3 = (create, dep1, dep2, dep3) => {\n  const cache2 = getCached$2(() => /* @__PURE__ */ new WeakMap(), cache1$3, dep1);\n  const cache3 = getCached$2(() => /* @__PURE__ */ new WeakMap(), cache2, dep2);\n  return getCached$2(create, cache3, dep3);\n};\nfunction selectAtom(anAtom, selector, equalityFn = Object.is) {\n  return memo3(\n    () => {\n      const EMPTY = Symbol();\n      const selectValue = ([value, prevSlice]) => {\n        if (prevSlice === EMPTY) {\n          return selector(value);\n        }\n        const slice = selector(value, prevSlice);\n        return equalityFn(prevSlice, slice) ? prevSlice : slice;\n      };\n      const derivedAtom = atom((get) => {\n        const prev = get(derivedAtom);\n        const value = get(anAtom);\n        return selectValue([value, prev]);\n      });\n      derivedAtom.init = EMPTY;\n      return derivedAtom;\n    },\n    anAtom,\n    selector,\n    equalityFn\n  );\n}\n\nconst frozenAtoms = /* @__PURE__ */ new WeakSet();\nconst deepFreeze = (obj) => {\n  if (typeof obj !== \"object\" || obj === null) return;\n  Object.freeze(obj);\n  const propNames = Object.getOwnPropertyNames(obj);\n  for (const name of propNames) {\n    const value = obj[name];\n    deepFreeze(value);\n  }\n  return obj;\n};\nfunction freezeAtom(anAtom) {\n  if (frozenAtoms.has(anAtom)) {\n    return anAtom;\n  }\n  frozenAtoms.add(anAtom);\n  const origRead = anAtom.read;\n  anAtom.read = function(get, options) {\n    return deepFreeze(origRead.call(this, get, options));\n  };\n  if (\"write\" in anAtom) {\n    const origWrite = anAtom.write;\n    anAtom.write = function(get, set, ...args) {\n      return origWrite.call(\n        this,\n        get,\n        (...setArgs) => {\n          if (setArgs[0] === anAtom) {\n            setArgs[1] = deepFreeze(setArgs[1]);\n          }\n          return set(...setArgs);\n        },\n        ...args\n      );\n    };\n  }\n  return anAtom;\n}\nfunction freezeAtomCreator(createAtom) {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] freezeAtomCreator is deprecated, define it on users end\"\n    );\n  }\n  return (...args) => freezeAtom(createAtom(...args));\n}\n\nconst getCached$1 = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1$2 = /* @__PURE__ */ new WeakMap();\nconst memo2$1 = (create, dep1, dep2) => {\n  const cache2 = getCached$1(() => /* @__PURE__ */ new WeakMap(), cache1$2, dep1);\n  return getCached$1(create, cache2, dep2);\n};\nconst cacheKeyForEmptyKeyExtractor = {};\nconst isWritable = (atom2) => !!atom2.write;\nconst isFunction = (x) => typeof x === \"function\";\nfunction splitAtom(arrAtom, keyExtractor) {\n  return memo2$1(\n    () => {\n      const mappingCache = /* @__PURE__ */ new WeakMap();\n      const getMapping = (arr, prev) => {\n        let mapping = mappingCache.get(arr);\n        if (mapping) {\n          return mapping;\n        }\n        const prevMapping = prev && mappingCache.get(prev);\n        const atomList = [];\n        const keyList = [];\n        arr.forEach((item, index) => {\n          const key = keyExtractor ? keyExtractor(item) : index;\n          keyList[index] = key;\n          const cachedAtom = prevMapping && prevMapping.atomList[prevMapping.keyList.indexOf(key)];\n          if (cachedAtom) {\n            atomList[index] = cachedAtom;\n            return;\n          }\n          const read = (get) => {\n            const prev2 = get(mappingAtom);\n            const currArr = get(arrAtom);\n            const mapping2 = getMapping(currArr, prev2 == null ? void 0 : prev2.arr);\n            const index2 = mapping2.keyList.indexOf(key);\n            if (index2 < 0 || index2 >= currArr.length) {\n              const prevItem = arr[getMapping(arr).keyList.indexOf(key)];\n              if (prevItem) {\n                return prevItem;\n              }\n              throw new Error(\"splitAtom: index out of bounds for read\");\n            }\n            return currArr[index2];\n          };\n          const write = (get, set, update) => {\n            const prev2 = get(mappingAtom);\n            const arr2 = get(arrAtom);\n            const mapping2 = getMapping(arr2, prev2 == null ? void 0 : prev2.arr);\n            const index2 = mapping2.keyList.indexOf(key);\n            if (index2 < 0 || index2 >= arr2.length) {\n              throw new Error(\"splitAtom: index out of bounds for write\");\n            }\n            const nextItem = isFunction(update) ? update(arr2[index2]) : update;\n            if (!Object.is(arr2[index2], nextItem)) {\n              set(arrAtom, [\n                ...arr2.slice(0, index2),\n                nextItem,\n                ...arr2.slice(index2 + 1)\n              ]);\n            }\n          };\n          atomList[index] = isWritable(arrAtom) ? atom(read, write) : atom(read);\n        });\n        if (prevMapping && prevMapping.keyList.length === keyList.length && prevMapping.keyList.every((x, i) => x === keyList[i])) {\n          mapping = prevMapping;\n        } else {\n          mapping = { arr, atomList, keyList };\n        }\n        mappingCache.set(arr, mapping);\n        return mapping;\n      };\n      const mappingAtom = atom((get) => {\n        const prev = get(mappingAtom);\n        const arr = get(arrAtom);\n        const mapping = getMapping(arr, prev == null ? void 0 : prev.arr);\n        return mapping;\n      });\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        mappingAtom.debugPrivate = true;\n      }\n      mappingAtom.init = void 0;\n      const splittedAtom = isWritable(arrAtom) ? atom(\n        (get) => get(mappingAtom).atomList,\n        (get, set, action) => {\n          switch (action.type) {\n            case \"remove\": {\n              const index = get(splittedAtom).indexOf(action.atom);\n              if (index >= 0) {\n                const arr = get(arrAtom);\n                set(arrAtom, [\n                  ...arr.slice(0, index),\n                  ...arr.slice(index + 1)\n                ]);\n              }\n              break;\n            }\n            case \"insert\": {\n              const index = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n              if (index >= 0) {\n                const arr = get(arrAtom);\n                set(arrAtom, [\n                  ...arr.slice(0, index),\n                  action.value,\n                  ...arr.slice(index)\n                ]);\n              }\n              break;\n            }\n            case \"move\": {\n              const index1 = get(splittedAtom).indexOf(action.atom);\n              const index2 = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n              if (index1 >= 0 && index2 >= 0) {\n                const arr = get(arrAtom);\n                if (index1 < index2) {\n                  set(arrAtom, [\n                    ...arr.slice(0, index1),\n                    ...arr.slice(index1 + 1, index2),\n                    arr[index1],\n                    ...arr.slice(index2)\n                  ]);\n                } else {\n                  set(arrAtom, [\n                    ...arr.slice(0, index2),\n                    arr[index1],\n                    ...arr.slice(index2, index1),\n                    ...arr.slice(index1 + 1)\n                  ]);\n                }\n              }\n              break;\n            }\n          }\n        }\n      ) : atom((get) => get(mappingAtom).atomList);\n      return splittedAtom;\n    },\n    arrAtom,\n    keyExtractor || cacheKeyForEmptyKeyExtractor\n  );\n}\n\nfunction atomWithDefault(getDefault) {\n  const EMPTY = Symbol();\n  const overwrittenAtom = atom(EMPTY);\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    overwrittenAtom.debugPrivate = true;\n  }\n  const anAtom = atom(\n    (get, options) => {\n      const overwritten = get(overwrittenAtom);\n      if (overwritten !== EMPTY) {\n        return overwritten;\n      }\n      return getDefault(get, options);\n    },\n    (get, set, update) => {\n      if (update === RESET) {\n        set(overwrittenAtom, EMPTY);\n      } else if (typeof update === \"function\") {\n        const prevValue = get(anAtom);\n        set(overwrittenAtom, update(prevValue));\n      } else {\n        set(overwrittenAtom, update);\n      }\n    }\n  );\n  return anAtom;\n}\n\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nfunction withStorageValidator(validator) {\n  return (unknownStorage) => {\n    const storage = {\n      ...unknownStorage,\n      getItem: (key, initialValue) => {\n        const validate = (value2) => {\n          if (!validator(value2)) {\n            return initialValue;\n          }\n          return value2;\n        };\n        const value = unknownStorage.getItem(key, initialValue);\n        if (isPromiseLike(value)) {\n          return value.then(validate);\n        }\n        return validate(value);\n      }\n    };\n    return storage;\n  };\n}\nfunction createJSONStorage(getStringStorage = () => {\n  try {\n    return window.localStorage;\n  } catch (e) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      if (typeof window !== \"undefined\") {\n        console.warn(e);\n      }\n    }\n    return void 0;\n  }\n}, options) {\n  var _a;\n  let lastStr;\n  let lastValue;\n  const storage = {\n    getItem: (key, initialValue) => {\n      var _a2, _b;\n      const parse = (str2) => {\n        str2 = str2 || \"\";\n        if (lastStr !== str2) {\n          try {\n            lastValue = JSON.parse(str2, options == null ? void 0 : options.reviver);\n          } catch (e) {\n            return initialValue;\n          }\n          lastStr = str2;\n        }\n        return lastValue;\n      };\n      const str = (_b = (_a2 = getStringStorage()) == null ? void 0 : _a2.getItem(key)) != null ? _b : null;\n      if (isPromiseLike(str)) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (key, newValue) => {\n      var _a2;\n      return (_a2 = getStringStorage()) == null ? void 0 : _a2.setItem(\n        key,\n        JSON.stringify(newValue, options == null ? void 0 : options.replacer)\n      );\n    },\n    removeItem: (key) => {\n      var _a2;\n      return (_a2 = getStringStorage()) == null ? void 0 : _a2.removeItem(key);\n    }\n  };\n  const createHandleSubscribe = (subscriber2) => (key, callback, initialValue) => subscriber2(key, (v) => {\n    let newValue;\n    try {\n      newValue = JSON.parse(v || \"\");\n    } catch (e) {\n      newValue = initialValue;\n    }\n    callback(newValue);\n  });\n  let subscriber;\n  try {\n    subscriber = (_a = getStringStorage()) == null ? void 0 : _a.subscribe;\n  } catch (e) {\n  }\n  if (!subscriber && typeof window !== \"undefined\" && typeof window.addEventListener === \"function\" && window.Storage) {\n    subscriber = (key, callback) => {\n      if (!(getStringStorage() instanceof window.Storage)) {\n        return () => {\n        };\n      }\n      const storageEventCallback = (e) => {\n        if (e.storageArea === getStringStorage() && e.key === key) {\n          callback(e.newValue);\n        }\n      };\n      window.addEventListener(\"storage\", storageEventCallback);\n      return () => {\n        window.removeEventListener(\"storage\", storageEventCallback);\n      };\n    };\n  }\n  if (subscriber) {\n    storage.subscribe = createHandleSubscribe(subscriber);\n  }\n  return storage;\n}\nconst defaultStorage = createJSONStorage();\nfunction atomWithStorage(key, initialValue, storage = defaultStorage, options) {\n  const getOnInit = options == null ? void 0 : options.getOnInit;\n  const baseAtom = atom(\n    getOnInit ? storage.getItem(key, initialValue) : initialValue\n  );\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    baseAtom.debugPrivate = true;\n  }\n  baseAtom.onMount = (setAtom) => {\n    setAtom(storage.getItem(key, initialValue));\n    let unsub;\n    if (storage.subscribe) {\n      unsub = storage.subscribe(key, setAtom, initialValue);\n    }\n    return unsub;\n  };\n  const anAtom = atom(\n    (get) => get(baseAtom),\n    (get, set, update) => {\n      const nextValue = typeof update === \"function\" ? update(get(baseAtom)) : update;\n      if (nextValue === RESET) {\n        set(baseAtom, initialValue);\n        return storage.removeItem(key);\n      }\n      if (nextValue instanceof Promise) {\n        return nextValue.then((resolvedValue) => {\n          set(baseAtom, resolvedValue);\n          return storage.setItem(key, resolvedValue);\n        });\n      }\n      set(baseAtom, nextValue);\n      return storage.setItem(key, nextValue);\n    }\n  );\n  return anAtom;\n}\n\nfunction atomWithObservable(getObservable, options) {\n  const returnResultData = (result) => {\n    if (\"e\" in result) {\n      throw result.e;\n    }\n    return result.d;\n  };\n  const observableResultAtom = atom((get) => {\n    var _a;\n    let observable = getObservable(get);\n    const itself = (_a = observable[Symbol.observable]) == null ? void 0 : _a.call(observable);\n    if (itself) {\n      observable = itself;\n    }\n    let resolve;\n    const makePending = () => new Promise((r) => {\n      resolve = r;\n    });\n    const initialResult = options && \"initialValue\" in options ? {\n      d: typeof options.initialValue === \"function\" ? options.initialValue() : options.initialValue\n    } : makePending();\n    let setResult;\n    let lastResult;\n    const listener = (result) => {\n      lastResult = result;\n      resolve == null ? void 0 : resolve(result);\n      setResult == null ? void 0 : setResult(result);\n    };\n    let subscription;\n    let timer;\n    const isNotMounted = () => !setResult;\n    const start = () => {\n      if (subscription) {\n        clearTimeout(timer);\n        subscription.unsubscribe();\n      }\n      subscription = observable.subscribe({\n        next: (d) => listener({ d }),\n        error: (e) => listener({ e }),\n        complete: () => {\n        }\n      });\n      if (isNotMounted() && (options == null ? void 0 : options.unstable_timeout)) {\n        timer = setTimeout(() => {\n          if (subscription) {\n            subscription.unsubscribe();\n            subscription = void 0;\n          }\n        }, options.unstable_timeout);\n      }\n    };\n    start();\n    const resultAtom = atom(lastResult || initialResult);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      resultAtom.debugPrivate = true;\n    }\n    resultAtom.onMount = (update) => {\n      setResult = update;\n      if (lastResult) {\n        update(lastResult);\n      }\n      if (subscription) {\n        clearTimeout(timer);\n      } else {\n        start();\n      }\n      return () => {\n        setResult = void 0;\n        if (subscription) {\n          subscription.unsubscribe();\n          subscription = void 0;\n        }\n      };\n    };\n    return [resultAtom, observable, makePending, start, isNotMounted];\n  });\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    observableResultAtom.debugPrivate = true;\n  }\n  const observableAtom = atom(\n    (get) => {\n      const [resultAtom] = get(observableResultAtom);\n      const result = get(resultAtom);\n      if (result instanceof Promise) {\n        return result.then(returnResultData);\n      }\n      return returnResultData(result);\n    },\n    (get, set, data) => {\n      const [resultAtom, observable, makePending, start, isNotMounted] = get(observableResultAtom);\n      if (\"next\" in observable) {\n        if (isNotMounted()) {\n          set(resultAtom, makePending());\n          start();\n        }\n        observable.next(data);\n      } else {\n        throw new Error(\"observable is not subject\");\n      }\n    }\n  );\n  return observableAtom;\n}\n\nconst cache1$1 = /* @__PURE__ */ new WeakMap();\nconst memo1 = (create, dep1) => (cache1$1.has(dep1) ? cache1$1 : cache1$1.set(dep1, create())).get(dep1);\nconst isPromise$1 = (x) => x instanceof Promise;\nconst LOADING = { state: \"loading\" };\nfunction loadable(anAtom) {\n  return memo1(() => {\n    const loadableCache = /* @__PURE__ */ new WeakMap();\n    const refreshAtom = atom(0);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      refreshAtom.debugPrivate = true;\n    }\n    const derivedAtom = atom(\n      (get, { setSelf }) => {\n        get(refreshAtom);\n        let value;\n        try {\n          value = get(anAtom);\n        } catch (error) {\n          return { state: \"hasError\", error };\n        }\n        if (!isPromise$1(value)) {\n          return { state: \"hasData\", data: value };\n        }\n        const promise = value;\n        const cached1 = loadableCache.get(promise);\n        if (cached1) {\n          return cached1;\n        }\n        promise.then(\n          (data) => {\n            loadableCache.set(promise, { state: \"hasData\", data });\n            setSelf();\n          },\n          (error) => {\n            loadableCache.set(promise, { state: \"hasError\", error });\n            setSelf();\n          }\n        );\n        const cached2 = loadableCache.get(promise);\n        if (cached2) {\n          return cached2;\n        }\n        loadableCache.set(promise, LOADING);\n        return LOADING;\n      },\n      (_get, set) => {\n        set(refreshAtom, (c) => c + 1);\n      }\n    );\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      derivedAtom.debugPrivate = true;\n    }\n    return atom((get) => get(derivedAtom));\n  }, anAtom);\n}\n\nconst getCached = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1 = /* @__PURE__ */ new WeakMap();\nconst memo2 = (create, dep1, dep2) => {\n  const cache2 = getCached(() => /* @__PURE__ */ new WeakMap(), cache1, dep1);\n  return getCached(create, cache2, dep2);\n};\nconst isPromise = (x) => x instanceof Promise;\nconst defaultFallback = () => void 0;\nfunction unwrap(anAtom, fallback = defaultFallback) {\n  return memo2(\n    () => {\n      const promiseErrorCache = /* @__PURE__ */ new WeakMap();\n      const promiseResultCache = /* @__PURE__ */ new WeakMap();\n      const refreshAtom = atom(0);\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        refreshAtom.debugPrivate = true;\n      }\n      const promiseAndValueAtom = atom(\n        (get, { setSelf }) => {\n          get(refreshAtom);\n          const prev = get(promiseAndValueAtom);\n          const promise = get(anAtom);\n          if (!isPromise(promise)) {\n            return { v: promise };\n          }\n          if (promise !== (prev == null ? void 0 : prev.p)) {\n            promise.then(\n              (v) => {\n                promiseResultCache.set(promise, v);\n                setSelf();\n              },\n              (e) => {\n                promiseErrorCache.set(promise, e);\n                setSelf();\n              }\n            );\n          }\n          if (promiseErrorCache.has(promise)) {\n            throw promiseErrorCache.get(promise);\n          }\n          if (promiseResultCache.has(promise)) {\n            return {\n              p: promise,\n              v: promiseResultCache.get(promise)\n            };\n          }\n          if (prev && \"v\" in prev) {\n            return { p: promise, f: fallback(prev.v), v: prev.v };\n          }\n          return { p: promise, f: fallback() };\n        },\n        (_get, set) => {\n          set(refreshAtom, (c) => c + 1);\n        }\n      );\n      promiseAndValueAtom.init = void 0;\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        promiseAndValueAtom.debugPrivate = true;\n      }\n      return atom(\n        (get) => {\n          const state = get(promiseAndValueAtom);\n          if (\"f\" in state) {\n            return state.f;\n          }\n          return state.v;\n        },\n        (_get, set, ...args) => set(anAtom, ...args)\n      );\n    },\n    anAtom,\n    fallback\n  );\n}\n\nfunction atomWithRefresh(read, write) {\n  const refreshAtom = atom(0);\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    refreshAtom.debugPrivate = true;\n  }\n  return atom(\n    (get, options) => {\n      get(refreshAtom);\n      return read(get, options);\n    },\n    (get, set, ...args) => {\n      if (args.length === 0) {\n        set(refreshAtom, (c) => c + 1);\n      } else if (write) {\n        return write(get, set, ...args);\n      }\n    }\n  );\n}\n\nfunction atomWithLazy(makeInitial) {\n  const a = atom(void 0);\n  delete a.init;\n  Object.defineProperty(a, \"init\", {\n    get() {\n      return makeInitial();\n    }\n  });\n  return a;\n}\n\nexport { RESET, atomFamily, atomWithDefault, atomWithLazy, atomWithObservable, atomWithReducer, atomWithRefresh, atomWithReset, atomWithStorage, createJSONStorage, freezeAtom, freezeAtomCreator, loadable, selectAtom, splitAtom, withStorageValidator as unstable_withStorageValidator, unwrap };\n", "import { createContext, useContext, useRef } from 'react';\nimport type { ReactNode } from 'react';\nimport { createStore } from 'jotai/vanilla';\nimport type { WritableAtom } from 'jotai/vanilla';\nimport {\n  useAtom as useAtomOrig,\n  useAtomValue as useAtomValueOrig,\n  useSetAtom as useSetAtomOrig,\n  useStore as useStoreOrig,\n} from 'jotai/react';\nimport { useHydrateAtoms } from 'jotai/react/utils';\n\ntype Store = ReturnType<typeof createStore>;\ntype AnyWritableAtom = WritableAtom<unknown, any[], any>;\n\nexport function createIsolation() {\n  const StoreContext = createContext<Store | null>(null);\n\n  function Provider({\n    store,\n    initialValues = [],\n    children,\n  }: {\n    store?: Store;\n    initialValues?: Iterable<readonly [AnyWritableAtom, unknown]>;\n    children: ReactNode;\n  }) {\n    const storeRef = useRef(store);\n    if (!storeRef.current) {\n      storeRef.current = createStore();\n    }\n    useHydrateAtoms(initialValues as any, { store: storeRef.current });\n    return (\n      <StoreContext.Provider value={storeRef.current}>\n        {children}\n      </StoreContext.Provider>\n    );\n  }\n\n  const useStore = ((options?: any) => {\n    const store = useContext(StoreContext);\n    if (!store) throw new Error('Missing Provider from createIsolation');\n    return useStoreOrig({ store, ...options });\n  }) as typeof useStoreOrig;\n\n  const useAtom = ((anAtom: any, options?: any) => {\n    const store = useStore();\n    return useAtomOrig(anAtom, { store, ...options });\n  }) as typeof useAtomOrig;\n\n  const useAtomValue = ((anAtom: any, options?: any) => {\n    const store = useStore();\n    return useAtomValueOrig(anAtom, { store, ...options });\n  }) as typeof useAtomValueOrig;\n\n  const useSetAtom = ((anAtom: any, options?: any) => {\n    const store = useStore();\n    return useSetAtomOrig(anAtom, { store, ...options });\n  }) as typeof useSetAtomOrig;\n\n  return { Provider, useStore, useAtom, useAtomValue, useSetAtom };\n}\n", "import { atom, type Atom } from 'jotai';\nimport type { AnyAtomFamily, AnyAtom, AnyWritableAtom, Scope } from './types';\n\nconst globalScopeKey: { name?: string } = {};\nif (process.env.NODE_ENV !== 'production') {\n  globalScopeKey.name = 'unscoped';\n  globalScopeKey.toString = toString;\n}\n\ntype GlobalScopeKey = typeof globalScopeKey;\n\nexport function createScope(\n  atoms: Set<AnyAtom>,\n  atomFamilies: Set<AnyAtomFamily>,\n  parentScope: Scope | undefined,\n  scopeName?: string | undefined,\n): Scope {\n  const explicit = new WeakMap<AnyAtom, [AnyAtom, Scope?]>();\n  const implicit = new WeakMap<AnyAtom, [AnyAtom, Scope?]>();\n  type ScopeMap = WeakMap<AnyAtom, [AnyAtom, Scope?]>;\n  const inherited = new WeakMap<Scope | GlobalScopeKey, ScopeMap>();\n\n  const currentScope: Scope = {\n    getAtom,\n    cleanup() {},\n    prepareWriteAtom(anAtom, originalAtom, implicitScope) {\n      if (\n        originalAtom.read === defaultRead &&\n        isWritableAtom(originalAtom) &&\n        isWritableAtom(anAtom) &&\n        originalAtom.write !== defaultWrite &&\n        currentScope !== implicitScope\n      ) {\n        // atom is writable with init and holds a value\n        // we need to preserve the value, so we don't want to copy the atom\n        // instead, we need to override write until the write is finished\n        const { write } = originalAtom;\n        anAtom.write = createScopedWrite(\n          originalAtom.write.bind(\n            originalAtom,\n          ) as (typeof originalAtom)['write'],\n          implicitScope,\n        );\n        return () => {\n          anAtom.write = write;\n        };\n      }\n      return undefined;\n    },\n  };\n\n  if (scopeName && process.env.NODE_ENV !== 'production') {\n    currentScope.name = scopeName;\n    currentScope.toString = toString;\n  }\n\n  // populate explicitly scoped atoms\n  for (const anAtom of atoms) {\n    explicit.set(anAtom, [cloneAtom(anAtom, currentScope), currentScope]);\n  }\n\n  const cleanupFamiliesSet = new Set<() => void>();\n  for (const atomFamily of atomFamilies) {\n    for (const param of atomFamily.getParams()) {\n      const anAtom = atomFamily(param);\n      if (!explicit.has(anAtom)) {\n        explicit.set(anAtom, [cloneAtom(anAtom, currentScope), currentScope]);\n      }\n    }\n    const cleanupFamily = atomFamily.unstable_listen((e) => {\n      if (e.type === 'CREATE' && !explicit.has(e.atom)) {\n        explicit.set(e.atom, [cloneAtom(e.atom, currentScope), currentScope]);\n      } else if (!atoms.has(e.atom)) {\n        explicit.delete(e.atom);\n      }\n    });\n    cleanupFamiliesSet.add(cleanupFamily);\n  }\n  currentScope.cleanup = combineVoidFunctions(\n    currentScope.cleanup,\n    ...Array.from(cleanupFamiliesSet),\n  );\n\n  /**\n   * Returns a scoped atom from the original atom.\n   * @param anAtom\n   * @param implicitScope the atom is implicitly scoped in the provided scope\n   * @returns the scoped atom and the scope of the atom\n   */\n  function getAtom<T extends AnyAtom>(\n    anAtom: T,\n    implicitScope?: Scope,\n  ): [T, Scope?] {\n    if (explicit.has(anAtom)) {\n      return explicit.get(anAtom) as [T, Scope];\n    }\n    if (implicitScope === currentScope) {\n      // dependencies of explicitly scoped atoms are implicitly scoped\n      // implicitly scoped atoms are only accessed by implicit and explicit scoped atoms\n      if (!implicit.has(anAtom)) {\n        implicit.set(anAtom, [cloneAtom(anAtom, implicitScope), implicitScope]);\n      }\n      return implicit.get(anAtom) as [T, Scope];\n    }\n    const scopeKey = implicitScope ?? globalScopeKey;\n    if (parentScope) {\n      // inherited atoms are copied so they can access scoped atoms\n      // but they are not explicitly scoped\n      // dependencies of inherited atoms first check if they are explicitly scoped\n      // otherwise they use their original scope's atom\n      if (!inherited.get(scopeKey)?.has(anAtom)) {\n        const [ancestorAtom, explicitScope] = parentScope.getAtom(\n          anAtom,\n          implicitScope,\n        );\n        setInheritedAtom(\n          inheritAtom(ancestorAtom, anAtom, explicitScope),\n          anAtom,\n          implicitScope,\n          explicitScope,\n        );\n      }\n      return inherited.get(scopeKey)!.get(anAtom) as [T, Scope];\n    }\n    if (!inherited.get(scopeKey)?.has(anAtom)) {\n      // non-primitive atoms may need to access scoped atoms\n      // so we need to create a copy of the atom\n      setInheritedAtom(inheritAtom(anAtom, anAtom), anAtom);\n    }\n    return inherited.get(scopeKey)!.get(anAtom) as [T, Scope?];\n  }\n\n  function setInheritedAtom<T extends AnyAtom>(\n    scopedAtom: T,\n    originalAtom: T,\n    implicitScope?: Scope,\n    explicitScope?: Scope,\n  ) {\n    const scopeKey = implicitScope ?? globalScopeKey;\n    if (!inherited.has(scopeKey)) {\n      inherited.set(scopeKey, new WeakMap());\n    }\n    inherited.get(scopeKey)!.set(\n      originalAtom,\n      [\n        scopedAtom, //\n        explicitScope,\n      ].filter(Boolean) as [T, Scope?],\n    );\n  }\n\n  /**\n   * @returns a copy of the atom for derived atoms or the original atom for primitive and writable atoms\n   */\n  function inheritAtom<T>(\n    anAtom: Atom<T>,\n    originalAtom: Atom<T>,\n    implicitScope?: Scope,\n  ) {\n    if (originalAtom.read !== defaultRead) {\n      return cloneAtom(originalAtom, implicitScope);\n    }\n    return anAtom;\n  }\n\n  /**\n   * @returns a scoped copy of the atom\n   */\n  function cloneAtom<T>(originalAtom: Atom<T>, implicitScope?: Scope) {\n    // avoid reading `init` to preserve lazy initialization\n    const scopedAtom: Atom<T> = Object.create(\n      Object.getPrototypeOf(originalAtom),\n      Object.getOwnPropertyDescriptors(originalAtom),\n    );\n\n    if (scopedAtom.read !== defaultRead) {\n      scopedAtom.read = createScopedRead<typeof scopedAtom>(\n        originalAtom.read.bind(originalAtom),\n        implicitScope,\n      );\n    }\n\n    if (\n      isWritableAtom(scopedAtom) &&\n      isWritableAtom(originalAtom) &&\n      scopedAtom.write !== defaultWrite\n    ) {\n      scopedAtom.write = createScopedWrite(\n        originalAtom.write.bind(originalAtom),\n        implicitScope,\n      );\n    }\n\n    return scopedAtom;\n  }\n\n  function createScopedRead<T extends Atom<unknown>>(\n    read: T['read'],\n    implicitScope?: Scope,\n  ): T['read'] {\n    return function scopedRead(get, opts) {\n      return read(\n        function scopedGet(a) {\n          const [scopedAtom] = getAtom(a, implicitScope);\n          return get(scopedAtom);\n        }, //\n        opts,\n      );\n    };\n  }\n\n  function createScopedWrite<T extends AnyWritableAtom>(\n    write: T['write'],\n    implicitScope?: Scope,\n  ): T['write'] {\n    return function scopedWrite(get, set, ...args) {\n      return write(\n        function scopedGet(a) {\n          const [scopedAtom] = getAtom(a, implicitScope);\n          return get(scopedAtom);\n        },\n        function scopedSet(a, ...v) {\n          const [scopedAtom] = getAtom(a, implicitScope);\n          return set(scopedAtom, ...v);\n        },\n        ...args,\n      );\n    };\n  }\n\n  return currentScope;\n}\n\nfunction isWritableAtom(anAtom: AnyAtom): anAtom is AnyWritableAtom {\n  return 'write' in anAtom;\n}\n\nconst { read: defaultRead, write: defaultWrite } = atom<unknown>(null);\n\nfunction toString(this: { name: string }) {\n  return this.name;\n}\n\nfunction combineVoidFunctions(...fns: (() => void)[]) {\n  return function combinedFunctions() {\n    for (const fn of fns) {\n      fn();\n    }\n  };\n}\n", "import type { Store, Scope } from './types';\n\nfunction PatchedStore() {}\n\n/**\n * @returns a patched store that intercepts get and set calls to apply the scope\n */\nexport function createPatchedStore(baseStore: Store, scope: Scope): Store {\n  const store: Store = {\n    ...baseStore,\n    get(anAtom, ...args) {\n      const [scopedAtom] = scope.getAtom(anAtom);\n      return baseStore.get(scopedAtom, ...args);\n    },\n    set(anAtom, ...args) {\n      const [scopedAtom, implicitScope] = scope.getAtom(anAtom);\n      const restore = scope.prepareWriteAtom(scopedAtom, anAtom, implicitScope);\n      try {\n        return baseStore.set(scopedAtom, ...args);\n      } finally {\n        restore?.();\n      }\n    },\n    sub(anAtom, ...args) {\n      const [scopedAtom] = scope.getAtom(anAtom);\n      return baseStore.sub(scopedAtom, ...args);\n    },\n    // TODO: update this patch to support devtools\n  };\n  return Object.assign(Object.create(PatchedStore.prototype), store);\n}\n\n/**\n * @returns true if the current scope is the first descendant scope under Provider\n */\nexport function isTopLevelScope(parentStore: Store) {\n  return !(parentStore instanceof PatchedStore);\n}\n", "import { Provider, useStore } from 'jotai/react';\nimport {\n  type EffectCallback,\n  createContext,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n  type PropsWithChildren,\n} from 'react';\nimport { createScope } from './scope';\nimport type { AnyAtom, AnyAtomFamily, Store, Scope } from './types';\nimport { createPatchedStore, isTopLevelScope } from './patchedStore';\n\nconst ScopeContext = createContext<{\n  scope: Scope | undefined;\n  baseStore: Store | undefined;\n}>({ scope: undefined, baseStore: undefined });\n\nexport function ScopeProvider({\n  atoms,\n  atomFamilies,\n  children,\n  debugName,\n}: PropsWithChildren<{\n  atoms: Iterable<AnyAtom>;\n  atomFamilies?: Iterable<AnyAtomFamily>;\n  debugName?: string;\n}>): JSX.Element;\nexport function ScopeProvider({\n  atoms,\n  atomFamilies,\n  children,\n  debugName,\n}: PropsWithChildren<{\n  atoms?: Iterable<AnyAtom>;\n  atomFamilies: Iterable<AnyAtomFamily>;\n  debugName?: string;\n}>): JSX.Element;\nexport function ScopeProvider({\n  atoms,\n  atomFamilies,\n  children,\n  debugName,\n}: PropsWithChildren<{\n  atoms?: Iterable<AnyAtom>;\n  atomFamilies?: Iterable<AnyAtomFamily>;\n  debugName?: string;\n}>) {\n  const parentStore: Store = useStore();\n  let { scope: parentScope, baseStore = parentStore } =\n    useContext(ScopeContext);\n  // if this ScopeProvider is the first descendant scope under Provider then it is the top level scope\n  // https://github.com/jotaijs/jotai-scope/pull/33#discussion_r1604268003\n  if (isTopLevelScope(parentStore)) {\n    parentScope = undefined;\n    baseStore = parentStore;\n  }\n\n  // atomSet is used to detect if the atoms prop has changed.\n  const atomSet = new Set(atoms);\n  const atomFamilySet = new Set(atomFamilies);\n\n  function initialize() {\n    const scope = createScope(atomSet, atomFamilySet, parentScope, debugName);\n    return {\n      patchedStore: createPatchedStore(baseStore, scope),\n      scopeContext: { scope, baseStore },\n      hasChanged(current: {\n        baseStore: Store;\n        parentScope: Scope | undefined;\n        atomSet: Set<AnyAtom>;\n        atomFamilySet: Set<AnyAtomFamily>;\n      }) {\n        return (\n          parentScope !== current.parentScope ||\n          baseStore !== current.baseStore ||\n          !isEqualSet(atomSet, current.atomSet) ||\n          !isEqualSet(atomFamilySet, current.atomFamilySet)\n        );\n      },\n    };\n  }\n\n  const [state, setState] = useState(initialize);\n  const { hasChanged, scopeContext, patchedStore } = state;\n  if (hasChanged({ parentScope, atomSet, atomFamilySet, baseStore })) {\n    scopeContext.scope?.cleanup();\n    setState(initialize);\n  }\n  const { cleanup } = scopeContext.scope;\n  useEvent(() => cleanup, []);\n  return (\n    <ScopeContext.Provider value={scopeContext}>\n      <Provider store={patchedStore}>{children}</Provider>\n    </ScopeContext.Provider>\n  );\n}\n\nfunction isEqualSet(a: Set<unknown>, b: Set<unknown>) {\n  return a === b || (a.size === b.size && Array.from(a).every((v) => b.has(v)));\n}\n\nfunction useEvent(fn: EffectCallback, deps: unknown[]) {\n  const ref = useRef(fn);\n  ref.current = fn;\n  useEffect(() => ref.current(), deps);\n}\n"],
  "mappings": "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",
  "names": ["atom", "createIsolation", "StoreContext", "createContext", "Provider", "store", "initialValues", "children", "storeRef", "useRef", "current", "createStore", "useHydrateAtoms", "_jsx", "value", "useStore", "options", "useContext", "Error", "useStoreOrig", "_extends", "useAtom", "anAtom", "useAtomOrig", "useAtomValue", "useAtomValueOrig", "useSetAtom", "useSetAtomOrig", "globalScopeKey", "process", "name", "toString", "createScope", "atoms", "atomFamilies", "parentScope", "scopeName", "explicit", "WeakMap", "implicit", "inherited", "currentScope", "getAtom", "cleanup", "prepareWriteAtom", "originalAtom", "implicitScope", "read", "defaultRead", "isWritableAtom", "write", "defaultWrite", "createScopedWrite", "bind", "undefined", "set", "cloneAtom", "cleanupFamiliesSet", "Set", "atomFamily", "param", "getParams", "has", "cleanupFamily", "unstable_listen", "e", "type", "atom", "delete", "add", "combineVoidFunctions", "Array", "from", "_inherited$get2", "get", "scopeKey", "_inherited$get", "ancestorAtom", "explicitScope", "setInheritedAtom", "inheritAtom", "scopedAtom", "filter", "Boolean", "Object", "create", "getPrototypeOf", "getOwnPropertyDescriptors", "createScopedRead", "scopedRead", "opts", "scopedGet", "a", "scopedWrite", "args", "scopedSet", "v", "fns", "combinedFunctions", "fn", "PatchedStore", "createPatchedStore", "baseStore", "scope", "restore", "sub", "assign", "prototype", "isTopLevelScope", "parentStore", "ScopeContext", "ScopeProvider", "debugName", "atomSet", "atomFamilySet", "initialize", "patchedStore", "scopeContext", "hasChanged", "isEqualSet", "state", "setState", "useState", "_scopeContext$scope", "useEvent", "b", "size", "every", "deps", "ref", "useEffect"]
}
